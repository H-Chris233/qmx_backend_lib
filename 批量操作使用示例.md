# 批量操作功能使用示例

本文档演示了 qmx_backend_lib 中批量操作功能的使用方法。

## 批量插入示例

### 学生记录批量插入
```rust
use qmx_backend_lib::student::{Person, StudentDatabase};

// 创建多个学生记录
let students = vec![
    Person::new(),
    Person::new(),
    Person::new(),
];

// 批量插入到数据库
let mut db = StudentDatabase::new();
let inserted_count = db.insert_batch(students);

println!("成功插入 {} 个学生记录", inserted_count);
```

### 现金记录批量插入
```rust
use qmx_backend_lib::cash::{Cash, CashDatabase};

// 创建多个现金记录
let cash_records = vec![
    Cash::new(Some(1)),  // 关联学生ID 1
    Cash::new(Some(2)),  // 关联学生ID 2
    Cash::new(None),    // 无关联学生
];

// 批量插入到数据库
let mut db = CashDatabase::new();
let inserted_count = db.insert_batch(cash_records);

println!("成功插入 {} 个现金记录", inserted_count);
```

## 批量更新示例

### 学生记录批量更新
```rust
use qmx_backend_lib::student::{Person, StudentDatabase};

let mut db = StudentDatabase::new();

// 先插入一些学生记录
let students = vec![Person::new(), Person::new(), Person::new()];
db.insert_batch(students);

// 获取所有UID
let uids: Vec<u64> = db.iter().map(|(&uid, _)| uid).collect();

// 批量更新年龄
let updated_count = db.update_batch(&uids, |student| {
    student.set_age(25);
    true
});

println!("成功更新 {} 个学生记录的年龄", updated_count);

// 条件批量更新 - 只更新特定条件的学生
let updated_count = db.update_batch(&uids, |student| {
    if student.age < 20 {
        student.set_age(20);
        true
    } else {
        false
    }
});

println!("成功更新 {} 个年龄小于20的学生记录", updated_count);
```

### 现金记录批量更新
```rust
use qmx_backend_lib::cash::{Cash, CashDatabase};

let mut db = CashDatabase::new();

// 先插入一些现金记录
let cash_records = vec![Cash::new(None), Cash::new(None), Cash::new(None)];
db.insert_batch(cash_records);

// 获取所有UID
let uids: Vec<u64> = db.iter().map(|(&uid, _)| uid).collect();

// 批量添加金额
let updated_count = db.update_batch(&uids, |cash| {
    cash.add(100);
    true
});

println!("成功更新 {} 个现金记录", updated_count);

// 条件批量更新 - 只更新金额大于50的记录
let updated_count = db.update_batch(&uids, |cash| {
    if cash.cash > 50 {
        cash.add(50);
        true
    } else {
        false
    }
});

println!("成功更新 {} 个金额大于50的现金记录", updated_count);
```

## 批量删除示例

### 学生记录批量删除
```rust
use qmx_backend_lib::student::{Person, StudentDatabase};

let mut db = StudentDatabase::new();

// 插入一些学生记录
let students = vec![Person::new(), Person::new(), Person::new()];
db.insert_batch(students);

// 获取所有UID
let uids: Vec<u64> = db.iter().map(|(&uid, _)| uid).collect();

// 批量删除
let removed_count = db.remove_batch(&uids);

println!("成功删除 {} 个学生记录", removed_count);
```

### 现金记录批量删除
```rust
use qmx_backend_lib::cash::{Cash, CashDatabase};

let mut db = CashDatabase::new();

// 插入一些现金记录
let cash_records = vec![Cash::new(None), Cash::new(None), Cash::new(None)];
db.insert_batch(cash_records);

// 获取所有UID
let uids: Vec<u64> = db.iter().map(|(&uid, _)| uid).collect();

// 批量删除
let removed_count = db.remove_batch(&uids);

println!("成功删除 {} 个现金记录", removed_count);
```

## 复杂批量操作示例

### 数据导入和批量处理
```rust
use qmx_backend_lib::student::{Person, StudentDatabase};
use qmx_backend_lib::cash::{Cash, CashDatabase};

// 模拟从外部数据源导入学生数据
fn import_students_from_csv(csv_data: &str) -> Vec<Person> {
    // 这里应该是CSV解析逻辑
    // 简化示例：直接创建一些学生
    vec![Person::new(), Person::new()]
}

// 模拟从外部数据源导入现金数据
fn import_cash_from_json(json_data: &str) -> Vec<Cash> {
    // 这里应该是JSON解析逻辑
    // 简化示例：直接创建一些现金记录
    vec![Cash::new(None), Cash::new(None)]
}

// 批量导入数据
let student_data = "name,age,class\n张三,18,一班\n李四,19,二班";
let cash_data = "[{\"amount\": 100}, {\"amount\": 200}]";

let students = import_students_from_csv(student_data);
let cash_records = import_cash_from_json(cash_data);

let mut student_db = StudentDatabase::new();
let mut cash_db = CashDatabase::new();

// 批量插入导入的数据
let student_count = student_db.insert_batch(students);
let cash_count = cash_db.insert_batch(cash_records);

println!("导入了 {} 个学生记录和 {} 个现金记录", student_count, cash_count);

// 批量处理数据 - 为所有学生设置初始现金余额
let student_uids: Vec<u64> = student_db.iter().map(|(&uid, _)| uid).collect();
let updated_count = student_db.update_batch(&student_uids, |student| {
    student.set_cash(1000);  // 设置初始现金余额
    true
});

println!("为 {} 个学生设置了初始现金余额", updated_count);
```

## 性能优化建议

1. **批量大小控制**: 对于大量数据，建议分批处理，每批100-1000条记录
2. **事务处理**: 虽然当前版本不支持事务，但建议在关键操作前后进行数据备份
3. **内存管理**: 批量操作会占用较多内存，注意监控内存使用情况
4. **错误处理**: 建议在批量操作过程中记录错误，避免因为单个记录失败导致整个操作失败

## 总结

批量操作功能为 qmx_backend_lib 提供了高效的数据处理能力，特别适合：

- 数据导入和迁移
- 批量数据更新
- 定期数据处理任务
- 大量数据的初始化

通过灵活的闭包设计，批量更新功能支持各种复杂的业务逻辑，同时保持了代码的简洁性和可维护性。